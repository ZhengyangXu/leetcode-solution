# 未完成的部分

## 300 最长上升子序列()
+ 有 nlogn 复杂度的解法
+ 记忆化搜索的解法



tyvj：http://www.joyoi.cn/
topcoder
poj、杭电
Google Sheet
codeforces





2. 两数相加 https://leetcode-cn.com/problems/add-two-numbers/description/
2. Add Two Numbers
https://leetcode.com/problems/add-two-numbers/description/



445. Add Two Numbers II
https://leetcode.com/problems/add-two-numbers-ii/description/

445. 两数相加 II
https://leetcode-cn.com/problems/add-two-numbers-ii/description/

组合问题可以使用动态规划来求解。





思路1：因为很可能头结点被删除，为了避免处理删除头结点的一些复杂的讨论工作，设置虚拟头结点一般是这类问题常见的做法。
思路2：使用递归的方式删除。





BAT机器学习面试1000题系列：七月在线：
https://blog.csdn.net/v_july_v/article/details/7041827


基本概念：
文本、模式、前缀、后缀、匹配、失配、字母表。

1、暴力匹配（朴素匹配）
算法是十分好理解，并且是显而易见的。暴力匹配法的缺点在于：在一轮匹配中，我们已经匹配了很多字符，但是只有一个不匹配的话，我们就会前功尽弃，一下子打回原形，继续开始下一轮。
暴力匹配，就相当于选择排序一样，每一轮都选出一个最小元素，下一轮，重新开始跑，这种算法不能观察到字符串本身有的特点，让算法更快地完成。

类比与插入排序，对于大致有序的数组，插入排序就可以很快完成。

2、KMP 
next 数组代表当前字符**之前**的字符串中，有多大长度的相同前缀后缀。



376


《算法导论》红黑树学习笔记 http://www.cnblogs.com/Anker/archive/2013/01/30/2882773.html
BST 中找一个元素的前驱和后继


KMP 算法理解相关文章：

[阮一峰《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)
[七月《https://blog.csdn.net/v_july_v/article/details/7041827》](https://blog.csdn.net/v_july_v/article/details/7041827)

[黄浩劫视频讲解](https://www.youtube.com/watch?v=dgPabAsTFa8)


http://www.cnblogs.com/golove/p/3222096.html 这篇博客告诉我们，标准 ASCII 码有 256 个字符。

Rabin-Karp 算法讲解比较细致的一篇文章：http://www.cnblogs.com/golove/p/3234673.html
Rabin-Karp 算法 Java 实现： https://blog.csdn.net/tyler_download/article/details/52457108


算法——字符串匹配之Rabin-Karp算法
https://blog.csdn.net/chenhanzhun/article/details/39895077
算法导论上的例子：
https://www.geeksforgeeks.org/searching-for-patterns-set-3-rabin-karp-algorithm/



算法数据结构,如何面试进入google
http://study.163.com/course/introduction.htm?courseId=1002942008#/courseDetail?tab=1


LintCode 题解：
https://github.com/awangdev/LintCode/blob/master/Java/Median.java





